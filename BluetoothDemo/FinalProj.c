#pragma config(Sensor, S1,     xTouch,         sensorTouch)
#pragma config(Sensor, S2,     yTouch,         sensorTouch)
#pragma config(Motor,  motorA,          xMotor,        tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorB,          yMotor,        tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorC,          clawMotor,     tmotorNormal, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int MAX_LENGTH = 20;
//Distance per degree of rotation
const float ENC_CONST = 40 / 360 * 3.2;
const float SQUARE_DIST = 5.715;
//Currently some arbitrary constant because I have no data for that yet
const int CLAW_CONSTANT = 20;

//Currently the command should be composed as following:
//{0x02, number of moves in this command, xCoord1, yCoord1, xCoord2, yCoord2, ... coords up to 17 ..., 0x04}
typedef struct{
  int size;
  ubyte data[MAX_LENGTH];
  string textValue;
}tByteArr;

bool dataChk(tByteArr message){
	if(message.data[0] != 0x02 || message.data[19] != 0x04){
		return false;
	}
	return true;
}

void resetMotors(){
	motor[xMotor] = -50;
	motor[yMotor] = -50;
	while(!SensorValue(xTouch) || !SensorValue(yTouch)){
		if(SensorValue(xTouch)){
			motor[xMotor] = 0;
		}
		if(SensorValue(yTouch)){
			motor[yMotor] = 0;
		}
	}
	nMotorEncoder[xMotor] = 0;
	nMotorEncoder[yMotor] = 0;
}

void moveToSquare(ubyte xCoord, ubyte yCoord, ubyte startX, ubyte startY){
	motor[xMotor] = 50;
	motor[yMotor] = 50;
	float deltaX = abs(xCoord - startX) * SQUARE_DIST, deltaY = abs(yCoord - startX) * SQUARE_DIST;
	while(nMotorEncoder[xMotor] < deltaX || nMotorEncoder[yMotor] < deltaY){
		if(nMotorEncoder[xMotor] >= deltaX){
			motor[xMotor] = 0;
		}
		if(nMotorEncoder[yMotor] >= deltaY){
			motor[yMotor] = 0;
		}
	}
	motor[xMotor] = 0;
	motor[yMotor] = 0;
}

void openClaw(){
		clawMotor = 20;
		while(nMotorEncoder[clawMotor] * ENC_CONST < CLAW_CONSTANT){}
		clawMotor = 0;
}

void closeClaw(){
		clawMotor = -20;
		while(nMotorEncoder[clawMotor] * ENC_CONST > 0){}
		clawMotor = 0;
		nMotorEncoder[clawMotor] = 0;
}

void getMessage(string &command){
	ubyte outMessage[1] = {0x00};
	if(nBTCurrentStreamIndex > 0){
		tByteArr messageBuffer;
		while(messageBuffer.data[0] == 0x00){
			nxtReadRawBluetooth(messageBuffer.data, MAX_LENGTH);
		}
		while(!dataChk(messageBuffer)){
			memset(messageBuffer.data, 0, MAX_LENGTH);
			outMessage[0] = 0x01;
			nxtWriteRawBluetooth(outMessage, 1);
			while(messageBuffer.data[0] == 0x00){
				nxtReadRawBluetooth(messageBuffer.data, MAX_LENGTH);
			}
		}
		outMessage[0] = 0x00;
		nxtWriteRawBluetooth(outMessage, 1);
		for(int count = 1; count < MAX_LENGTH - 1; count++){
			command += messageBuffer.data[count];
		}
		memset(messageBuffer.data, 0, MAX_LENGTH);
	}
	else{
		command = "NO CONNECTION!";
	}
}

void runCommand(string &coords){
	for(int count = 0; count < coords.size; count += 2){
		if(count < 2){
			moveToSquare(coords[count], coords[count + 1], 0, 0);
		}
		else{
			moveToSquare(coords[count], coords[count + 1], coords[count - 2], coords[count - 1]);
		}
		toggleClaw();
	}
	resetMotors();
}
	ubyte numOfMoves = command[1] - '0';
	ubyte coords[MAX_LENGTH] = {0};
	for(int count = 2; count < MAX_LENGTH - 1; count++){
		coords[count] = coords[count] - '0';
	}
	for(int count = 0; count < numOfMoves; count++){
		closeClaw();
		moveToSquare(coords[count * 4 + 2], coords[count * 4 + 3], coords[count * 4], coords[count * 4 + 1]);
		openClaw();
	}
}

task main(){
  setBluetoothRawDataMode();
  string message = "";
  while(!bBTRawMode){
	  wait1Msec(1);
  }
  
  while(nNxtButtonPressed != 0){
	while(nNxtButtonPressed != 3){ }
	getMessage(message);
	runCommand(message);
	resetMotors();
	nxtDisplayTextLine(2, "%s", message);
  }

  wait1Msec(10);
  btDisconnectAll();
  wait1Msec(10);
}
